# Переход на Event-Driven архитектуру

1. Проблемы и риски
  - сервисы `core-app` и `ins-comp-settlement` взаимодействуют с сервисом `ins-product-aggregator` синхронно, хотя данные не нужны в реальном времени
  (данные запрашиваются периодически и между запросами используются полученные результаты) это приводит к увеличению времени запроса по мере увеличения
  страховых компаний что может вызвать задержки при обработке пользовательских запросов или некорректные расчеты страховок (если в это время будут
  использоваться устаревшие данные)
  - ошибки при взаимодействия между сервисами связаные с задержками ответов или ошибками при взаимодействии с API страховых компаний это приводит или к
  расчету страховок на основании устаревших данных или простой сервисов до получения актуальных данных
  - сервис `ins-comp-settlement` раз в сутки осуществляет запрос в `core-app`, объем данных может быть достаточно большим что может привести к повышенной
  нагузке на сервис `core-app` и повлиять на отзывчивость системы в этот момент для пользователей
  - выглядит подозрительным использование сервисом `ins-comp-settlement` данных для расчета страховок от сервиса `core-app` (с периодичностью обновления 15 минут)
  и данных сервиса `ins-product-aggregator` (обновление раз в сутки), возможно это не противоречит имеемой бизнес логике, но выглядит логичнее сервису `ins-comp-settlement`
  использовать данные с одинаковой периодичностью обновления
  
2. Предлагаемые решения
  - Использовать асинхронное взаимодействие между сервисами `core-app`, `ins-comp-settlement` и `ins-product-aggregator` через очередь сообщений для получения 
  данных о доступных продуктах. Сервис `ins-product-aggregator` осуществляет периодический опрос внешних систем и кладет полученную информацию в виде события
  в очередь. Сервисы `core-app` и `ins-comp-settlement` получают данные из очереди и сохраняют в своей базе данных для дальнейшего использования. Это уменьшит 
  связанность между сервисами и в случае возникновения ошибок не повлияет на работу пользователей с приложением, так-же это упростит дальнейшее масштабирование
  сервисов. Сервис `ins-product-aggregator` при этом должен обрабатывать возникающие ошибки (повторы, логирование, мониторинг). Следует предусмотреть в `core-app`и `ins-comp-settlement` ситуацию, когда данные не обновлялиь какое-то время (это может быть из-за ошибки получения данных от внешнего сервиса) и например не предлагать 
  продукты от такого страховщика.
  - Использовать асинхронное взаимодействие между сервисами `core-app` и `ins-comp-settlement` через очередь сообщений для получения   данных о оформленных страховках.
  Сервис `core-app` осуществляет публикацию каждой оформленной страховки в очередь, которую вычитывает сервис `ins-comp-settlement`. Это позволит уменьшить нагрузку на `core-app` сервис. Для решения проблемы двойной записи операций (в БД и очередь) на стороное `core-app` сервиса следует использовать паттерн (Transactional outbox), который 
  будет записывать данные для отправки в отедльной таблице в одной транзакции с сохранением данных оформленной страховки. Из этой таблицы отдельный процесс вычитывает и отправляет через брокер сообщения.

[Диаграмму контейнеров в формате drawio](InsureTech_C4_сontainer-diagram_to-be.drawio.xml)

![схема](InsureTech_C4_сontainer-diagram_to-be.drawio.png)
